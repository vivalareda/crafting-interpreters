<repomix>This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-27T19:44:37.558Z<directory_structure>src/
  ast-printer.ts
  expr.ts
  interpreter.ts
  parser.ts
  reda.ts
  runtimeError.ts
  scanner.ts
  test.ts
  token.ts
.gitignore
bun.lock
package.json
README.md
tsconfig.json</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path="src/ast-printer.ts">import { Token, TokenType  } from &apos;./token&apos;;
import { BinaryExpr, GroupingExpr, LiteralExpr, UnaryExpr } from &apos;./expr&apos;;
import type { Expr, ExprVisitor } from &apos;./expr&apos;;

export class AstPrinter implements ExprVisitor&lt;string&gt; {
  print(expr: Expr): string {
    return expr.accept(this);
  }

  visitBinaryExpr(expr: BinaryExpr): string {
    return this.parenthesize(expr.operator.lexeme, expr.left, expr.right);
  }

  visitGroupingExpr(expr: GroupingExpr): string {
    return this.parenthesize(&quot;group&quot;, expr.expression);
  }

  visitLiteralExpr(expr: LiteralExpr): string {
    if (expr.value === null) return &quot;nil&quot;;
    return expr.value.toString();
  }

  visitUnaryExpr(expr: UnaryExpr): string {
    return this.parenthesize(expr.operator.lexeme, expr.right);
  }

  private parenthesize(name: string, ...exprs: Expr[]): string {
    let result = `(${name}`;
    for (const expr of exprs) {
      result += &quot; &quot; + expr.accept(this);
    }
    result += &quot;)&quot;;
    return result;
  }
}</file><file path="src/expr.ts">import { Token, TokenType  } from &apos;./token&apos;;

export interface Expr {
  accept&lt;R&gt;(visitor: ExprVisitor&lt;R&gt;): R;
}

export interface ExprVisitor&lt;R&gt; {
  visitBinaryExpr(expr: BinaryExpr): R;
  visitGroupingExpr(expr: GroupingExpr): R;
  visitLiteralExpr(expr: LiteralExpr): R;
  visitUnaryExpr(expr: UnaryExpr): R;
}

export class BinaryExpr implements Expr {
  left: Expr;
  operator: Token;
  right: Expr;

  constructor(left: Expr, operator: Token, right: Expr) {
    this.left = left;
    this.operator = operator;
    this.right = right;
  }

  accept&lt;R&gt;(visitor: ExprVisitor&lt;R&gt;): R {
    return visitor.visitBinaryExpr(this);
  }
}

export class GroupingExpr implements Expr {
  expression: Expr;

  constructor(expression: Expr) {
    this.expression = expression;
  }

  accept&lt;R&gt;(visitor: ExprVisitor&lt;R&gt;): R {
    return visitor.visitGroupingExpr(this);
  }
}

export class LiteralExpr implements Expr {
  value: true | false | null | number | string;

  constructor(value: true | false | null | number | string) {
    this.value = value;
  }

  accept&lt;R&gt;(visitor: ExprVisitor&lt;R&gt;): R {
    return visitor.visitLiteralExpr(this);
  }
}

export class UnaryExpr implements Expr {
  operator: Token;
  right: Expr;

  constructor(operator: Token, right: Expr) {
    this.operator = operator;
    this.right = right;
  }

  accept&lt;R&gt;(visitor: ExprVisitor&lt;R&gt;): R {
    return visitor.visitUnaryExpr(this);
  }
}</file><file path="src/interpreter.ts">import { Token, TokenType } from &quot;./token&quot;
import type { ExprVisitor, Expr } from &quot;./expr&quot;;
import { LiteralExpr, GroupingExpr, BinaryExpr, UnaryExpr } from &quot;./expr&quot;;
import { RuntimeError } from &quot;./runtimeError&quot;;
import { Reda } from &quot;./reda&quot;;

export class Interpreter implements ExprVisitor&lt;any&gt; {

  interpret(expression: Expr) {
    try {
      const value: any = this.evaluate(expression);
      console.log(this.stringify(value));
    } catch (error: any) {
      Reda.runtimeError(error);
    }
  }

  visitLiteralExpr(expr: LiteralExpr) {
    return expr.value;
  }

  visitGroupingExpr(expr: GroupingExpr) {
    return this.evaluate(expr.expression);
  }

  visitUnaryExpr(expr: UnaryExpr) {
    const right: any = this.evaluate(expr.right);

    switch (expr.operator.type) {
      case TokenType.MINUS:
        this.checkNumberOperand(expr.operator, right);
        return -(right as number)
      case TokenType.BANG:
        return !this.isTruthy(right);
    }
    return null;
  }

  private checkNumberOperand(operator: Token, operand: any) {
    if (typeof operand === &apos;number&apos;) return;
    throw new RuntimeError(operator, &quot;Operand must be number.&quot;);
  }

  private checkNumberOperands(operator: Token, left: any, right: any) {
    if (typeof left === &apos;number&apos; &amp;&amp; typeof right === &apos;number&apos;) return;

    throw new RuntimeError(operator, &quot;Operand must be number.&quot;);
  }

  private isTruthy(object: any): boolean {
    if (object === null) return false;
    if (typeof object === &apos;boolean&apos;) return object as boolean;
    return true;
  }

  private isEqual(a: any, b: any) {
    if (a === null &amp;&amp; b === null) return true;
    if (a === null) return false;

    if (typeof a === &apos;number&apos; || typeof a === &apos;string&apos; || typeof a === &apos;boolean&apos;) {
      return a === b;
    }

    return Object.is(a, b); 
  }

  private stringify(object: any): string {
    if (object === null) return &apos;nil&apos;;
    return object.toString();
  }

  visitBinaryExpr(expr: BinaryExpr) {
    const left: any = this.evaluate(expr.left);
    const right: any = this.evaluate(expr.right);

    switch (expr.operator.type) {
      case TokenType.GREATER:
        this.checkNumberOperands(expr.operator, left, right);
        return (left as number) &gt; (right as number)
      case TokenType.GREATER_EQUAL:
        this.checkNumberOperands(expr.operator, left, right);
        return (left as number) &gt;= (right as number)
      case TokenType.LESS:
        this.checkNumberOperands(expr.operator, left, right);
        return (left as number) &lt; (right as number)
      case TokenType.LESS_EQUAL:
        this.checkNumberOperands(expr.operator, left, right);
        return (left as number) &lt;= (right as number)
      case TokenType.MINUS:
        this.checkNumberOperands(expr.operator, left, right);
        return (left as number) - (right as number)
      case TokenType.PLUS:
        if (typeof left === &apos;number&apos; &amp;&amp; typeof right === &apos;number&apos;) {
          return (left as number) + (right as number);
        }

        if (typeof left === &apos;string&apos; &amp;&amp; typeof right === &apos;string&apos;) {
          return (left as string) + (right as string);
        }

        throw new RuntimeError(expr.operator, &quot;Operands must be two numbers or two strings.&quot;)
      case TokenType.SLASH:
        this.checkNumberOperands(expr.operator, left, right);
        return (left as number) / (right as number)
      case TokenType.STAR:
        this.checkNumberOperands(expr.operator, left, right);
        return (left as number) * (right as number)
      case TokenType.BANG_EQUAL: return !this.isEqual(left, right);
      case TokenType.EQUAL_EQUAL: return this.isEqual(left, right);
    }

    return null;
  }

  private evaluate(expr: Expr): any {
    return expr.accept(this);
  }

}</file><file path="src/parser.ts">import { Token, TokenType } from &quot;./token&quot;;
import type { Expr } from &quot;./expr&quot;;
import { BinaryExpr, GroupingExpr, LiteralExpr, UnaryExpr } from &quot;./expr&quot;;
import { Reda } from &quot;./reda&quot;;

export class Parser {
  private tokens: Token[];
  private current: number = 0;

  constructor(tokens: Token[]) {
    this.tokens = tokens;
  }

  public parse(): Expr {
    try {
      return this.expression();
    } catch (error) {
      return null;
    }
  }

  private expression(): Expr {
    return this.equality();
  }

  private equality(): Expr {
    let expr: Expr = this.comparison();

    while (this.match(TokenType.BANG_EQUAL, TokenType.EQUAL_EQUAL)) {
      const operator: Token = this.previous();
      const right: Expr = this.comparison();
      expr = new BinaryExpr(expr, operator, right);
    }

    return expr;
  }

  private comparison() {
    let expr = this.term();

    while (this.match(TokenType.GREATER, TokenType.GREATER_EQUAL, TokenType.LESS, TokenType.LESS_EQUAL)) {
      const operator: Token = this.previous();
      const right: Expr = this.term();
      expr = new BinaryExpr(expr, operator, right);
    }

    return expr;
  }

  private term(): Expr {
    let expr: Expr = this.factor();

    while (this.match(TokenType.MINUS, TokenType.PLUS)) {
      const operator: Token = this.previous();
      const right: Expr = this.factor();
      expr = new BinaryExpr(expr, operator, right);
    }

    return expr
  }

  private match(...types: TokenType[]): boolean {
    for (const type of types) {
      if (this.check(type)) {
        this.advance();
        return true;
      }
    }
    return false;
  }

  private consume(type: TokenType, message: string): Token {
    if (this.check(type)) return this.advance();

    throw Reda.tokenError(this.peek(), message);
  }

  private factor(): Expr {
    let expr: Expr = this.unary();

    while (this.match(TokenType.SLASH, TokenType.STAR)) {
      const operator: Token = this.previous();
      const right: Expr = this.unary();
      expr = new BinaryExpr(expr, operator, right);
    }

    return expr;
  }

  private unary(): Expr {
    if (this.match(TokenType.BANG, TokenType.MINUS)) {
      const operator: Token = this.previous();
      const right = this.unary();
      return new UnaryExpr(operator, right);
    }

    return this.primary();
  }

  private primary(): Expr {
    if (this.match(TokenType.FALSE)) return new LiteralExpr(false);
    if (this.match(TokenType.TRUE)) return new LiteralExpr(true);
    if (this.match(TokenType.NIL)) return new LiteralExpr(null);

    if (this.match(TokenType.NUMBER, TokenType.STRING)) {
      return new LiteralExpr(this.previous().literal);
    }

    if (this.match(TokenType.LEFT_PAREN)){
      let expr = this.expression();
      this.consume(TokenType.RIGHT_PAREN, &quot;Expect &apos;)&apos; after expression.&quot;);
      return new GroupingExpr(expr);
    }

    throw this.error(this.peek(), &quot;Expect expression.&quot;);
  }

  private check(type: TokenType): boolean {
    if (this.isAtEnd()) return false;
    return this.peek().type == type;
  }

  private advance(): Token {
    if (!this.isAtEnd()) this.current++;
    return this.previous();
  }

  private isAtEnd(): boolean {
    return this.peek().type == TokenType.EOF;
  }

  private peek(): Token {
    return this.tokens.at(this.current);
  }

  private previous(): Token {
    return this.tokens.at(this.current - 1)
  }

  private error(token: Token, message: string) {
    Reda.tokenError(token, message);
    return new Error(message);
  }

  private synchronize() {
    this.advance();

    while (!this.isAtEnd()) {
      if (this.previous().type == TokenType.SEMICOLON) return;

      switch (this.peek().type) {
        case TokenType.CLASS:
        case TokenType.FUN:
        case TokenType.VAR:
        case TokenType.FOR:
        case TokenType.IF:
        case TokenType.WHILE:
        case TokenType.PRINT:
        case TokenType.RETURN:
          return;
      }

      this.advance();
    }
  }
}</file><file path="src/reda.ts">import * as fs from &quot;fs&quot;;
import * as readline from &quot;readline&quot;;
import { Token, TokenType } from &quot;./token&quot;;
import { Scanner } from &quot;./scanner&quot;;
import { AstPrinter } from &quot;./ast-printer&quot;;
import { Parser } from &quot;./parser&quot;;
import { report } from &quot;process&quot;;
import { Interpreter } from &quot;./interpreter&quot;;
import type { RuntimeError } from &quot;./runtimeError&quot;;

export class Reda {
  private static readonly interpreter: Interpreter = new Interpreter();
  static hadError: boolean = false;
  static hadRuntimeError: boolean = false;

  main(args: string[]) {
    if (args.length &gt; 1) {
      console.log(&quot;Usage: jlox [script]&quot;);
      process.exit(64);
    } else if (args.length === 1) {
      this.runFile(args[0]);
    } else {
      this.runPrompt();
    }
  }

  private runFile(path: string) {
    fs.readFile(path, (err, data) =&gt; {
      if (err) throw err;
      console.log(data);
      this.run(data.toString());
    });

    if (Reda.hadError) process.exit(65);
  }

  private async runPrompt() {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    while (true) {
      const line = await new Promise&lt;string&gt;((resolve) =&gt; {
        rl.question(&quot;&gt; &quot;, resolve);
      });

      if (line === null) break;
      this.run(line);
      Reda.hadError = false;
    }

    rl.close();
  }

  private run(source: string) {
    const scanner = new Scanner(source);
    const tokens: Token[] = scanner.scanTokens();

    const parser = new Parser(tokens);
    const expression = parser.parse();

    if (Reda.hadError) process.exit(65);
    if (Reda.hadRuntimeError) process.exit(70);

    Reda.interpreter.interpret(expression);
  }

  static error(line: number, message: string): void {
    this.report(line, &quot;&quot;, message);
  }

  static runtimeError(error: RuntimeError) {
    console.error(error.message + &quot;\n[line &quot; + error.token.line + &quot;]&quot;);
    this.hadError = true;
  }

  static tokenError(token: Token, message: string): void {
    if (token.type === TokenType.EOF) {
      this.report(token.line, &quot; at end&quot;, message);
    } else {
      this.report(token.line, &quot; at &apos;&quot; + token.lexeme + &quot;&apos;&quot;, message);
    }
  }

  private static report(line: number, where: string, message: string): void {
    console.log(&quot;[line &quot; + line + &quot;] Error&quot; + where + &quot;: &quot; + message);
    this.hadError = true;
  }
}

if (require.main === module) {
  const reda = new Reda();
  reda.main(process.argv.slice(2));
}</file><file path="src/runtimeError.ts">import { TokenType, type Token } from &quot;./token&quot;;

export class RuntimeError extends Error {
  readonly token: Token;

  constructor(token: Token, message: string) {
    super(message);
    this.token = token;
  }

}</file><file path="src/scanner.ts">import { Token, TokenType } from &quot;./token&quot;;
import { Reda } from &quot;./reda.ts&quot;;

export class Scanner {
  private source: string;
  private tokens: Token[];
  private start: number = 0;
  private current: number = 0;
  private line: number = 1;

  private keywords: Map&lt;string, TokenType&gt;;

  constructor(source: string) {
    this.source = source;
    this.tokens = [];
    this.keywords = new Map&lt;string, TokenType&gt;([
      [&quot;and&quot;, TokenType.AND],
      [&quot;class&quot;, TokenType.CLASS],
      [&quot;else&quot;, TokenType.ELSE],
      [&quot;false&quot;, TokenType.FALSE],
      [&quot;for&quot;, TokenType.FOR],
      [&quot;fun&quot;, TokenType.FUN],
      [&quot;if&quot;, TokenType.IF],
      [&quot;nil&quot;, TokenType.NIL],
      [&quot;or&quot;, TokenType.OR],
      [&quot;print&quot;, TokenType.PRINT],
      [&quot;return&quot;, TokenType.RETURN],
      [&quot;super&quot;, TokenType.SUPER],
      [&quot;this&quot;, TokenType.THIS],
      [&quot;true&quot;, TokenType.TRUE],
      [&quot;var&quot;, TokenType.VAR],
      [&quot;while&quot;, TokenType.WHILE],
    ]);
  }

  private isAtEnd(): boolean {
    return this.current &gt;= this.source.length;
  }

  private advance(): string {
    this.current++;
    return this.source[this.current - 1];
  }

  private addToken(type: TokenType): void {
    this.addTokenWithLiteral(type, null);
  }

  private addTokenWithLiteral(type: TokenType, literal: string | number | boolean | null) {
    let text: string = this.source.substring(this.start, this.current);
    this.tokens.push(new Token(type, text, literal, this.line));
  }

  private scanToken(): void {
    let char: string = this.advance();

    switch (char) {
      case &quot;(&quot;:
        this.addToken(TokenType.LEFT_PAREN);
        break;
      case &quot;)&quot;:
        this.addToken(TokenType.RIGHT_PAREN);
        break;
      case &quot;{&quot;:
        this.addToken(TokenType.LEFT_BRACE);
        break;
      case &quot;}&quot;:
        this.addToken(TokenType.RIGHT_BRACE);
        break;
      case &quot;,&quot;:
        this.addToken(TokenType.COMMA);
        break;
      case &quot;.&quot;:
        this.addToken(TokenType.DOT);
        break;
      case &quot;-&quot;:
        this.addToken(TokenType.MINUS);
        break;
      case &quot;+&quot;:
        this.addToken(TokenType.PLUS);
        break;
      case &quot;;&quot;:
        this.addToken(TokenType.SEMICOLON);
        break;
      case &quot;*&quot;:
        this.addToken(TokenType.STAR);
        break;
      case &quot;!&quot;: {
        this.addToken(this.match(&quot;=&quot;) ? TokenType.BANG_EQUAL : TokenType.BANG);
        break;
      }
      case &quot;=&quot;: {
        this.addToken(
          this.match(&quot;=&quot;) ? TokenType.EQUAL_EQUAL : TokenType.EQUAL,
        );
        break;
      }
      case &quot;&lt;&quot;: {
        this.addToken(this.match(&quot;=&quot;) ? TokenType.LESS_EQUAL : TokenType.LESS);
        break;
      }
      case &quot;&gt;&quot;: {
        this.addToken(
          this.match(&quot;=&quot;) ? TokenType.GREATER_EQUAL : TokenType.GREATER,
        );
        break;
      }
      case &quot;/&quot;: {
        if (this.match(&quot;/&quot;)) {
          while (this.peek() != &quot;\n&quot; &amp;&amp; !this.isAtEnd()) {
            this.advance();
          }
        } else {
          this.addToken(TokenType.SLASH);
        }
        break;
      }
      case &quot; &quot;:
      case &quot;\r&quot;:
      case &quot;\t&quot;:
        break;
      case &quot;\n&quot;:
        this.line++;
        break;
      case &apos;&quot;&apos;:
        this.string();
        break;
      default: {
        if (this.isDigit(char)) {
          this.number();
        } else if (this.isAlpha(char)) {
          this.identifier();
        } else {
          Reda.error(this.line, &quot;Unexpected character.&quot;);
        }
        break;
      }
    }
  }

  scanTokens(): Token[] {
    while (!this.isAtEnd()) {
      this.start = this.current;
      this.scanToken();
    }

    this.tokens.push(new Token(TokenType.EOF, &quot;&quot;, null, this.line));

    return this.tokens;
  }

  private identifier(): void {
    while (this.isAlphaNumeric(this.peek())) this.advance();
    let text:string = this.source.substring(this.start, this.current);
    let type:TokenType = this.keywords.get(text);
    if (type == null) type = TokenType.IDENTIFIER;
    this.addToken(TokenType.IDENTIFIER);
  }

  private number(): void {
    while (this.isDigit(this.peek())) this.advance();

    if (this.peek() == &quot;.&quot; &amp;&amp; this.isDigit(this.peekNext())) {
      this.advance();

      while (this.isDigit(this.peek())) this.advance();
    }

    let value: number = parseFloat(
      this.source.substring(this.start, this.current),
    );
    this.addTokenWithLiteral(TokenType.NUMBER, value);
  }

  private string() {
    while (this.peek() != &apos;&quot;&apos; &amp;&amp; !this.isAtEnd()) {
      if (this.peek() == &quot;\n&quot;) this.line++;
      this.advance();
    }

    if (this.isAtEnd()) {
      Reda.error(this.line, &quot;Unterminated string.&quot;);
      return;
    }

    this.advance();

    let value: string = this.source.substring(this.start + 1, this.current - 1);
    this.addTokenWithLiteral(TokenType.STRING, value);
  }

  private match(expected: string): boolean {
    if (this.isAtEnd()) return false;
    if (this.source.charAt(this.current) != expected) return false;

    this.current++;
    return true;
  }

  private peek(): string {
    if (this.isAtEnd()) return &quot;\0&quot;;
    return this.source.charAt(this.current);
  }

  private peekNext(): string {
    if (this.current + 1 &gt;= this.source.length) return &quot;\0&quot;;
    return this.source.charAt(this.current + 1);
  }

  private isAlpha(c: string): boolean {
    return (c &gt;= &quot;a&quot; &amp;&amp; c &lt;= &quot;z&quot;) || (c &gt;= &quot;A&quot; &amp;&amp; c &lt;= &quot;Z&quot;) || c == &quot;_&quot;;
  }

  private isAlphaNumeric(c:string): boolean {
    return this.isAlpha(c) || this.isDigit(c);
  }

  private isDigit(c: string): boolean {
    return c &gt;= &quot;0&quot; &amp;&amp; c &lt;= &quot;9&quot;;
  }
}</file><file path="src/test.ts">import { Token, TokenType } from &apos;./token&apos;;
import { Scanner } from &apos;./scanner&apos;;
import { Parser } from &apos;./parser&apos;;
import { AstPrinter } from &apos;./ast-printer&apos;;

function parse(source: string): void {
  console.log(&quot;Source:&quot;, source);
  
  // Scan tokens
  const scanner = new Scanner(source);
  const tokens = scanner.scanTokens();
  
  console.log(&quot;Tokens:&quot;, tokens);
  
  // Parse tokens
  const parser = new Parser(tokens);
  const expression = parser.parse(); // You&apos;ll need to add this method
  
  if (expression) {
    // Print the AST
    const printer = new AstPrinter();
    console.log(&quot;AST:&quot;, printer.print(expression));
  } else {
    console.log(&quot;Error: Failed to parse expression&quot;);
  }
  
  console.log(&quot;----------------------------&quot;);
}

// Test with various expressions
parse(&quot;1 + 2&quot;);
parse(&quot;1 + 2 * 3&quot;);
parse(&quot;-123 * (45.67)&quot;);
parse(&quot;!true == false&quot;);
parse(&quot;1 &gt; 2 == 3 &lt; 4&quot;);</file><file path="src/token.ts">export enum TokenType {
  LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,
  COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,
  BANG, BANG_EQUAL, EQUAL, EQUAL_EQUAL,
  GREATER, GREATER_EQUAL, LESS, LESS_EQUAL,
  IDENTIFIER, STRING, NUMBER,
  AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,
  PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,
  EOF
}

export class Token {
  type: TokenType;
  lexeme: string;
  literal: string | number | boolean | null;
  line: number;

  constructor(token: TokenType, lexeme: string, literal: string | number | boolean | null, line: number) {
    this.type = token;
    this.lexeme = lexeme;
    this.literal = literal;
    this.line = line;
  }

  toString() {
    return this.type + &quot; &quot; + this.lexeme + &quot; &quot; + this.literal;
  }
}</file><file path=".gitignore"># Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Caches

.cache

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of &apos;npm pack&apos;

*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store</file><file path="bun.lock">{
  &quot;lockfileVersion&quot;: 1,
  &quot;workspaces&quot;: {
    &quot;&quot;: {
      &quot;name&quot;: &quot;crafting-interpreters&quot;,
      &quot;devDependencies&quot;: {
        &quot;@types/bun&quot;: &quot;latest&quot;,
        &quot;@types/node&quot;: &quot;^22.13.4&quot;,
      },
      &quot;peerDependencies&quot;: {
        &quot;typescript&quot;: &quot;^5.7.3&quot;,
      },
    },
  },
  &quot;packages&quot;: {
    &quot;@types/bun&quot;: [&quot;@types/bun@1.2.2&quot;, &quot;&quot;, { &quot;dependencies&quot;: { &quot;bun-types&quot;: &quot;1.2.2&quot; } }, &quot;sha512-tr74gdku+AEDN5ergNiBnplr7hpDp3V1h7fqI2GcR/rsUaM39jpSeKH0TFibRvU0KwniRx5POgaYnaXbk0hU+w==&quot;],

    &quot;@types/node&quot;: [&quot;@types/node@22.13.4&quot;, &quot;&quot;, { &quot;dependencies&quot;: { &quot;undici-types&quot;: &quot;~6.20.0&quot; } }, &quot;sha512-ywP2X0DYtX3y08eFVx5fNIw7/uIv8hYUKgXoK8oayJlLnKcRfEYCxWMVE1XagUdVtCJlZT1AU4LXEABW+L1Peg==&quot;],

    &quot;@types/ws&quot;: [&quot;@types/ws@8.5.14&quot;, &quot;&quot;, { &quot;dependencies&quot;: { &quot;@types/node&quot;: &quot;*&quot; } }, &quot;sha512-bd/YFLW+URhBzMXurx7lWByOu+xzU9+kb3RboOteXYDfW+tr+JZa99OyNmPINEGB/ahzKrEuc8rcv4gnpJmxTw==&quot;],

    &quot;bun-types&quot;: [&quot;bun-types@1.2.2&quot;, &quot;&quot;, { &quot;dependencies&quot;: { &quot;@types/node&quot;: &quot;*&quot;, &quot;@types/ws&quot;: &quot;~8.5.10&quot; } }, &quot;sha512-RCbMH5elr9gjgDGDhkTTugA21XtJAy/9jkKe/G3WR2q17VPGhcquf9Sir6uay9iW+7P/BV0CAHA1XlHXMAVKHg==&quot;],

    &quot;typescript&quot;: [&quot;typescript@5.7.3&quot;, &quot;&quot;, { &quot;bin&quot;: { &quot;tsc&quot;: &quot;bin/tsc&quot;, &quot;tsserver&quot;: &quot;bin/tsserver&quot; } }, &quot;sha512-84MVSjMEHP+FQRPy3pX9sTVV/INIex71s9TL2Gm5FG/WG1SqXeKyZ0k7/blY/4FdOzI12CBy1vGc4og/eus0fw==&quot;],

    &quot;undici-types&quot;: [&quot;undici-types@6.20.0&quot;, &quot;&quot;, {}, &quot;sha512-Ny6QZ2Nju20vw1SRHe3d9jVu6gJ+4e3+MMpqu7pqE5HT6WsTSlce++GQmK5UXS8mzV8DSYHrQH+Xrf2jVcuKNg==&quot;],
  }
}</file><file path="package.json">{
  &quot;name&quot;: &quot;crafting-interpreters&quot;,
  &quot;module&quot;: &quot;index.ts&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;devDependencies&quot;: {
    &quot;@types/bun&quot;: &quot;latest&quot;,
    &quot;@types/node&quot;: &quot;^22.13.4&quot;
  },
  &quot;peerDependencies&quot;: {
    &quot;typescript&quot;: &quot;^5.7.3&quot;
  }
}</file><file path="README.md"># crafting-interpreters

To install dependencies:

```bash
bun install
```

To run:

```bash
bun run index.ts
```

This project was created using `bun init` in bun v1.2.1. [Bun](https://bun.sh) is a fast all-in-one JavaScript runtime.</file><file path="tsconfig.json">{
  &quot;compilerOptions&quot;: {
    // Enable latest features
    &quot;lib&quot;: [&quot;ESNext&quot;, &quot;DOM&quot;],
    &quot;target&quot;: &quot;ESNext&quot;,
    &quot;module&quot;: &quot;ESNext&quot;,
    &quot;moduleDetection&quot;: &quot;force&quot;,
    &quot;jsx&quot;: &quot;react-jsx&quot;,
    &quot;allowJs&quot;: true,

    // Bundler mode
    &quot;moduleResolution&quot;: &quot;bundler&quot;,
    &quot;allowImportingTsExtensions&quot;: true,
    &quot;verbatimModuleSyntax&quot;: true,
    &quot;noEmit&quot;: true,

    // Best practices
    &quot;strict&quot;: true,
    &quot;strictNullChecks&quot;: false,
    &quot;skipLibCheck&quot;: true,
    &quot;noFallthroughCasesInSwitch&quot;: true,

    // Some stricter flags (disabled by default)
    &quot;noUnusedLocals&quot;: false,
    &quot;noUnusedParameters&quot;: false,
    &quot;noPropertyAccessFromIndexSignature&quot;: false
  }
}</file></files></repomix>